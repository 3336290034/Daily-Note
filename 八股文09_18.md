# 今日八股文---孰真孰假，还是平常心去对待

## 我想知道，如果不用RTOS去开发多任务项目，就只用裸机的话，有没有好的解决方案？

- 轮询机制：在主循环中依次调用各个任务的处理函数，每个任务执行完后主动让出CPU，进入下一个任务
  - 优点就是实现简单，也是在我们初步学习还不了解RTOS时，比较常用的一种方案
    - 实现最简单，几乎没有额外资源分配（无需栈空间分配、上下文切换）
    - 适合资源极度受限的场景
  - 缺点就是实时性差：一个任务执行时间过长会影响其他后续所有任务，无法处理需要 “等待” 的场景（如延时、外设就绪等待）

- 定时器中断的时间片轮转：通过定时器固定周期（如1ms）产生中断，在中断中触发任务切换，每个任务分配固定`时间片`，超时后强制切换到下一个任务
  - 关键点：
    - 用定时器（如SysTick）作为调度时钟；
    - 为每个任务分配独立栈空间，切换时保存/恢复CPU寄存器（上下文）
    - 任务需设计为`可重入`（避免全局变量冲突）
  - 代码示例

  ```c
    // 任务控制块
    typedef struct {
        void (*func)(void);  // 任务函数
        uint32_t *stack;     // 任务栈指针
        uint8_t time_slice;  // 时间片长度（单位：定时器周期）
    } Task_t;

    Task_t tasks[3];  // 任务列表
    uint8_t current_task = 0;  // 当前运行任务索引

    // 定时器中断服务函数（调度器核心）
    void TIM_IRQHandler(void) {
        static uint8_t tick_count = 0;
        tick_count++;
        
        // 时间片用完，切换任务
        if (tick_count >= tasks[current_task].time_slice) {
            tick_count = 0;
            // 保存当前任务上下文（寄存器）
            // ...（汇编或编译器 intrinsic 实现）
            // 切换到下一个任务
            current_task = (current_task + 1) % 3;
            // 恢复下一个任务上下文
            // ...
        }
    }
  ```

  - 优点：任务公平调度，避免单个任务独占CPU
  - 缺点：需要手动处理上下文切换，用汇编实现上下文切换比较复杂

- 前后台系统：核心逻辑是 ：紧急事件通过中断立即响应，非紧急任务在主循环中轮询执行，通过`全局标志位`实现`前后台通信`
  - 后台（Background）：主循环执行非紧急任务（如数据处理、UI 刷新）
  - 前台（Foreground）：中断服务程序（ISR）处理紧急任务（如按键触发、传感器中断）
  - 代码示例

  ```c
    volatile uint8_t key_pressed_flag = 0;  // 前后台通信标志

    // 按键中断服务程序（前台）
    void KEY_IRQHandler(void) {
        key_pressed_flag = 1;  // 置位标志
    }

    // 后台任务：处理按键（非紧急）
    void background_key_process(void) {
        if (key_pressed_flag) {
            // 处理按键逻辑（如点亮LED）
            key_pressed_flag = 0;  // 清除标志
        }
    }

    // 后台任务：传感器读取
    void background_sensor_read(void) {
        // 读取传感器数据（非紧急）
    }

    int main(void) {
        // 初始化中断、外设
        while(1) {
            background_key_process();
            background_sensor_read();
            // 其他后台任务...
        }
    }
  ```

  - 优点：紧急任务响应快（可以通过中断优先级保证）；实现简单，资源消耗低
  - 缺点：后台任务仍存在轮询的阻塞问题（看上面的代码也能知道）；中断切记不可以执行延时操作
  - 所以这个方案用于哪种`紧急/非紧急`很明确的任务划分场景（比如在我的项目二，报警中断+常规数据采集）

- 状态机驱动：将`每个任务拆分成多个状态`，主循环通过状态变量（这里可以用枚举）控制任务执行流程，每个状态只执行`少量逻辑`后就立马返回，避免阻塞
  - 代码示例

  ```c
  // 任务1：状态机
    typedef enum {
        SENSOR_IDLE,
        SENSOR_START,
        SENSOR_WAIT,
        SENSOR_READ,
        SENSOR_PROCESS
    } SensorState_t;

    SensorState_t sensor_state = SENSOR_IDLE;
    uint32_t sensor_wait_time = 0;

    void task_sensor(void) {
        switch(sensor_state) {
            case SENSOR_IDLE:
                // 空闲状态，等待触发
                if (start_sensor_flag) {
                    sensor_state = SENSOR_START;
                }
                break;
            case SENSOR_START:
                // 启动传感器
                sensor_start();
                sensor_wait_time = get_tick();  // 记录当前时间
                sensor_state = SENSOR_WAIT;
                break;
            case SENSOR_WAIT:
                // 等待传感器就绪（非阻塞延时）
                if (get_tick() - sensor_wait_time > 100) {  // 100ms超时
                    sensor_state = SENSOR_READ;
                }
                break;
            case SENSOR_READ:
                // 读取数据
                sensor_data = sensor_read();
                sensor_state = SENSOR_PROCESS;
                break;
            case SENSOR_PROCESS:
                // 处理数据
                process_data(sensor_data);
                sensor_state = SENSOR_IDLE;
                start_sensor_flag = 0;
                break;
        }
    }

    int main(void) {
        while(1) {
            task_sensor();  // 状态机任务
            task_display(); // 其他状态机任务
            // ...
        }
    }
  ```

  - 优点：天然的自带避免阻塞机制
  - 缺点：要对任务状态精确把握，否则会出现`状态机异常`；多个任务的时序协调需额外设计如 （任务A必须在任务B之后执行，任务C需要任务D的数据，这些依赖无法通过状态机自身解决，需要额外设计协调机制）

- 事件驱动：基于`事件`触发任务执行，任务平时处于休眠状态，当事件（如定时器超时、外设就绪、标志位触发）发生时才被唤醒执行
  - 核心是需要：`事件队列&&事件分发器`
  - 代码示例

  ```c
    // 事件类型定义
    typedef enum {
        EVENT_TIMER_10MS,
        EVENT_UART_RX,
        EVENT_KEY_PRESS
    } EventType_t;

    // 事件结构体
    typedef struct {
        EventType_t type;
        void *data;  // 事件附加数据
    } Event_t;

    // 事件队列（环形缓冲区）
    Event_t event_queue[10];
    uint8_t queue_head = 0, queue_tail = 0;

    // 发送事件
    void event_post(EventType_t type, void *data) {
        // 事件入队（需考虑线程安全，可禁用中断）
        event_queue[queue_tail].type = type;
        event_queue[queue_tail].data = data;
        queue_tail = (queue_tail + 1) % 10;
    }

    // 事件处理函数
    void handle_timer_10ms(void *data) {
        // 10ms定时任务（如LED刷新）
    }

    void handle_uart_rx(void *data) {
        // 串口接收处理
    }

    // 事件分发器（主循环）
    void event_dispatcher(void) {
        while(1) {
            if (queue_head != queue_tail) {  // 队列非空
                Event_t event = event_queue[queue_head];
                queue_head = (queue_head + 1) % 10;
                
                // 根据事件类型调用处理函数
                switch(event.type) {
                    case EVENT_TIMER_10MS:
                        handle_timer_10ms(event.data);
                        break;
                    case EVENT_UART_RX:
                        handle_uart_rx(event.data);
                        break;
                    // 其他事件...
                }
            }
        }
    }

    // 定时器中断：每10ms发送事件
    void TIM_IRQHandler(void) {
        event_post(EVENT_TIMER_10MS, NULL);
    }

    int main(void) {
        event_dispatcher();  // 启动事件分发
    }
    ```

  - 缺点就是需要考虑事件队列溢出，发送事件的`线程安全`
  - 优点：按需执行，模块化设计，解耦
  - 事件源多的话用这个方便

## 你提到的可重入函数是什么

- 核心原则：函数内不使用全局 / 静态变量，或通过临界区（关闭中断）保护共享资源
- 允许被中断后再次调用（嵌套调用或被其他任务调用），且不会导致数据错误的函数
- 看两个代码示例

```c
int g_temp;  // 全局变量
int add(int a, int b) {
    g_temp = a;  // 步骤1：保存a到全局变量
    // 若此时被中断切走，其他任务可能修改g_temp
    return g_temp + b;  // 步骤2：使用g_temp（可能已被修改）
}

int add(int a, int b) {
    int temp = a;  // 局部变量（存在栈中，每个任务有独立栈）
    return temp + b;  // 即使被中断，栈数据独立，不会冲突
}
```

- 时间片轮转中，任务可能被定时器中断强行打断（比如执行到一半被切走），若函数不可重入，再次执行时可能读取到错误的中间状态
- 豆书记有话说：intrinsic：<https://www.doubao.com/thread/w07c2bb6617c4966b>
