# 准备星宸科技嵌入式AE二面

## 项目里面为什么要移植usbx实现虚拟串口？

- 这主要是基于项目需求、通信效率、系统兼容性和开发便捷性这几点去考量的：
- 第一就是满足项目需求里面的`工业互联通信需要`，上位机需要去通过中控读取获得传感器的数据，还有通过中控去实现对中控或者传感器的升级等这些功能，这就对通信提出了较高的要求了，选择USB虚拟串口可以提供一种“标准化 + 高带宽”的通信接口，可以实现稳定的双向数据传输；其次相比传统的485、232这些，USB虚拟串口可以支持更高的波特率，对于实际工业生产数据量大是很利好的
- 第二就是对于`调试和监控`比较方便，我可以通过软件❓
- 第三就是`跨平台兼容性`了，USB CDC ACM是标准协议，对Win/Linux/Mac都支持，这就方便了我在不同平台下的开发和调试，无需额外驱动
- 第四点就是`资源复用`，就是我可以使用原有的，物理的这个usb接口去实现虚拟串口，中间还不需要增加额外芯片，简化了硬件的工作，这样看的话还可以节省资源，这里就会涉及到`物理设备和逻辑设备`了，我就简单提一下❓
- 最后说说usbx的技术优势吧，这也可以回答为什么我是用usbx去实现虚拟串口❓
  - ❓
  - 其他的可以实现usb通信的比如，，，❓

## 你刚刚说到利于调试和监控，我想知道在你的项目里是怎么操作的？对于其他的通信协议是如何调试的？

## 你移植usbx实现usb，，，时碰到的难点是什么？移植思路是什么？（补充09_02内容）

- 在移植之前，我先是去学习了usbx的文档，了解了usbx的架构和工作原理（正所谓知己知彼百战不殆）
  - 此处可以复用09_02处的回答
  - 所以我们的难点就在于怎么初始化硬件以确保 Controller layer 可以正常运行和如何编写app，向上提供数据传输的接口函数

- 现在讲讲移植过程和实现虚拟串口的过程：主要是四个阶段“基础工程配置 + 硬件层适配 + 协议栈集成 + 应用层优化”

- 基础工程配置 + 硬件层适配
  - 当然第一步都是添加USBX库，在CubeMX上进行简单的配置❓（配了啥，这个需要去熟悉一下usb.c文件）然后一步步的编译调试，到不报错就行
  - STM32CubeMX生成的USB初始化代码（usb.c）和我们的usbx的控制层（usbx_control.c）是不兼容的（就是说usb.c的代码没有启动USB控制器，也没有和USBX简历联系），很明显的表现就是你虽然编译过了，最后上电跑的时候PC就会提示“未知USB设备”，这其实就是usb里面额枚举失败
  - 这里我们的解决方法就是去修改usb.c文件，1.手动调用USBX的函数，添加对USB串口的支持 2.调用初始化函数绑定硬件句柄：就是把stm32 usb控制器的句柄，传给usbx系统，然后usbx系统会使用这个句柄来操作硬件 3.补充对usb电源使能的代码，最后启动usb控制器
  - 到这里我们可以进行一些简单的测试，这是我们的PC已经可以正常识别到我们的usb了
- 协议栈集成
  - 这里主要是“描述符配置”，在usb_device_descriptor.c，描述符就是usb世界里的“身份证”嘛，我们通过设备描述符声明为CDC设备，PC可以看懂这些描述符，通过配置描述符添加CDC接口
  - 最后就是调用usbx函数初始化协议栈、调用类驱动激活函数，激活CDC类驱动
  - 这里应该还有一些步骤，目的是为了适配我们的FreeRTOS，在ux_user.h（这个文件就和FreeRTOSConfig.h一样）它里面有很多宏开关，通过UX_STANDALONE这个宏来决定使用RTOS还是裸机，再有就是选中Host/Device模式
- 应用层优化
  - ST官方给的接发数据函数是一些基础的回调函数，激活函数这些，实际的收发逻辑需要我们自己去弄，那我们就采用了这样一个 “异步完成阻塞传输和阻塞接收” 的模式，（回调函数的调用关系要清楚）
  - 我们实现发送函数为：异步完成通知:使用信号量而非直接等待传输完成，允许系统在传输过程中执行其他任务，这样的方式（阻塞）也可以折射出RTOS相对裸机的好处
  - 加入RTOS优化：使用 g_xUSBUART_Send 信号量来实现发送完成的通知机制，接受也类似，，，

## 我看到你使用了RTOS，你的任务是怎么设计的？

- 任务函数， 栈大小， 优先级是RTOS任务三要素
- 关于项目中任务xxx的设计，主要还是得从 “任务实时性要求+调度公平性+资源竞争处理” 这三方面去考量的
- 在项目上使用RTOS，具体有这些任务：USB通信任务、Modbus Server任务、传感器数据采集任务
  - 当时我梳理了项目中所有核心任务的诉求，发现它们的实时性要求和业务优先级没有本质差异，因此选择相同优先级，实际运行中没有出现调度问题
  - 这些任务的实时性需求均为 “毫秒级且无紧急优先级区分”，而FreeRTOS在 “相同优先级任务” 下会采用时间片调度（默认时间片由系统 tick 决定），能保证每个任务公平获得 CPU 资源，实际运行中没有出现数据丢失、显示延迟的问题
  - 同时，我额外处理了 “资源竞争” 问题 —— 比如 LCD 显示任务和传感器数据任务都可能访问 LCD，我用了 FreeRTOS 的互斥锁（Mutex）做同步，避免了任务冲突，这比单纯依赖优先级更关键
  - 当然，这是基于当前项目需求的设计。如果后续项目迭代，我会根据任务实时性的变化调整优先级：若增加 “传感器故障报警任务”（比如传感器离线需立即上报上位机）—— 会将其优先级设为最高，确保紧急事件不被其他任务阻塞，若传感器采样周期从 1 秒改为 100ms（实时性提升）—— 会将 “数据采集任务” 优先级高于 “LCD 显示任务”（1 秒刷新），避免采样数据因调度延迟丢失

- 上面是关于调度的，下面是关于任务栈资源方面的：
  - 首先是系统级堆大小的配置：使用 STM32CubeMX 配置 FreeRTOS 时，需先设定系统总堆大小（供 FreeRTOS 动态创建任务、信号量等使用），我前面设置的是8kb，后面看项目进展，同时考虑到我们的芯片的存储是够的，就直接一步到位改成了80kb，确保能容纳所有任务的栈空间及系统对象（如互斥锁、队列）的内存占用
  - 单个任务栈大小的配置，这个我就是根据实际的任务函数处理的事务和内存开销来配置的了，若任务涉及复杂逻辑（如传感器数据解析、多函数嵌套），会适当增大栈大小
  - 当然，实际开发的时候，会开启 FreeRTOS 的 “栈溢出检测” 功能

- 豆书记关于任务栈和C堆栈的看法<https://www.doubao.com/thread/w775067e9e03a14f5>