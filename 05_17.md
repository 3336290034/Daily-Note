/* FreeRTOS学习遇到的问题 */ 

1， FreeRTOS任务创建三要素：[任务函数， 栈大小， 优先级]；  当然啦，还有一些其他的参数 ： 比如给函数的参数、
	1. 创建任务就是调用 xTaskCreate() 函数，再往里面加入参数就成，这还得注意是不是静态创建、返回值、要不要句柄、等等；
	2. 估算栈的大小：[定义局部变量的大小、 函数调用的深度] ----> 函数调用+局部变量+现场保存；
	3. 注意保护通信过程；
			使用 “全局变量 + 条件判断 + 延时函数” ---> [不可靠的办法]
			使用 “信号量”？？？
			
2， FreeRTOS删除任务：要使用到任务的句柄；
	1. 频繁的创建和删除任务好吗？ ： 频繁的分配内存和频繁的释放内存，这样容易造成内存的碎片，多次执行之后可能就分配不到内存了
	
3， FreeRTOS的任务状态 + 任务优先级：合理运用，能出奇效！
	1. 四种状态：
		1. Blocked（等待某些event， 也叫阻塞）
		2. Suspend（暂停，不干活的）
		3. Ready  （随时准备运行的）
		4. Running（正在运行的）
	2. 一个任务被创建出来一定是处于ready状态的，有机会它就会运行的
	3. 暂停状态：自己调用vTaskSuspend()或者由别的任务调用这函数；（和suspend对应的函数是resume）
	4. 只有就绪态Ready可以转换为运行态Running

4， 任务调度三大关键：
	1. 高优先级任务未执行完， 低优先级的任务无法执行；
	2. 一旦高优先级的任务就绪，立刻执行；
	3. 最高优先级的任务有多个， 它们会轮流执行；
	[用链表来管理这些任务， 启动内核的时候，会创建一个空闲任务prvIdleTask]
	[TCB结构体的用处在这里就体现出来了]
	
	4. 当产生SysTick中断时，会发起一次调度：先从上到下（高优先级到低优先级）遍历一遍这个ResdyList，在第一个非空的链表xxxList，进入；
		在这个链表里面找到pxCurrentTCB指向的任务，运行；------这是针对相同优先级的就绪态任务的；
		[调度时很复杂的，并不仅仅是遍历就绪列表，上面只是简化理解一下]；
		在Tick中断函数里面：
			1. cnt++；
			2. 判断阻塞链表里头是否有可回复的任务，有的话就把它恢复成就绪态；
			3. 发起调度；
			
5， 空闲任务非常的重要：
	一个任务要退出的话：必须[自杀 vTaskDelte(NULL);]或者[他杀vTaskDelte(xxx_handle);];
	A 杀  B: A收尸 （即释放栈，释放被删除内务的内存）；
	B 自杀: 由空闲任务收尸；
	所以，在任务后面要加vTaskDelay()函数，进入到阻塞状态，让出CPU资源，让空闲任务的函数得到执行；
	空闲任务只有两个状态（双R）；
	
	？？延时函数建议不使用死循环，改成vTaskDelay()阻塞类型的；
	
6， 两个Delay函数……，延时函数死循环和进入阻塞态的由啥子不同啊？

7， 同步与互斥:涉及[临界资源]、 [原子操作]
	全局变量同步的缺陷：等待的任务也会耗费CPU资源；
	全局变量互斥的缺陷：临界资源的保护不充分，不到位，小小小概率引发冲突 ； 简陋办法:关中断使无法任务切换，但如果由更紧急的任务怎么办？
		为什么都关中断了，还是会有和 g同步缺陷一样的情况发生？
		……………………………………
	任务之间如何进行通信呢？ 可以使用全局变量，但是有可能你在修改全局变量的时间进行了任务切换，毁！（呃呃呃，怎么通信不重要，重要的是保证结果是正确的就行；
	
	信号量semaphore：保存的是计数值，这个值可以是多种多样的值，；
	互斥量mutex：特殊化的信号量（只能取0和1），可以使用互斥量来保护某些临界资源，；
		使用互斥量是还会引入其他问题：比如优先级，于是就有了对应的优先级反转、优先级继承等方法；
		
8， NWatch开源项目；