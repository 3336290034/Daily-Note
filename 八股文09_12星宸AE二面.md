# 星宸AE二面准备

## i++ 和 ++i哪个效率更高？

- 先看看豆书记怎么说：<https://www.doubao.com/thread/w6573895bc133dd8d>
- 在大多数情况下，++i（前缀递增）的效率等于或高于i++（后缀递增），具体差异取决于操作的对象类型和编译器优化，核心原因在于两者的实现逻辑不同
- 基本数据类型（如int、long等）：效率几乎无差异，对于int这类简单类型，++i和i++的操作非常简单：
  - ++i：直接将i的值加 1，返回加 1 后的结果（无临时变量）
  - i++：先保存i的原始值（可能需要一个临时变量），再将i加 1，最后返回原始值
  - 但现代编译器（如 GCC、Clang）会对这种简单操作进行优化，自动消除i++中临时变量的开销，生成的机器码完全相同，因此，对基本类型而言，两者效率无实际差异
- 复杂类型（如自定义类、迭代器等）：++i效率更高，对于自定义对象（如 C++ 中的迭代器、封装的计数器类），++i和i++的实现逻辑差异会导致明显的效率差距：
  - ++i（前缀）：通常实现为 “先修改对象自身，再返回自身引用”，无需拷贝对象
  - i++（后缀）：必须 “先拷贝原始对象，再修改原对象，最后返回拷贝的临时对象”，会产生额外的拷贝开销

## NULL、空指针、void* 三者有什么区别？有什么联系？

- NULL
  - NULL 是一个预定义的宏常量，用于表示 “空指针值”。其本质是一个代表 “无有效地址” 的符号
  - 在 C 语言中，通常定义为 (void*)0[将0强制转换为无类型指针]
  - 其核心作用是：给指针赋值，表明该指针不指向任何有效的内存地址
- 空指针
  - 空指针是指针的一种状态：当一个指针的值为 NULL（或 nullptr）时，它就是空指针
  - 任何类型的指针都可以成为空指针（如 int*、char*、void* 等）；
  - 对空指针解引用（*p）会导致未定义行为（通常是程序崩溃）
- void*
  - void* 是一种无类型指针（通用指针），表示 “指向未知类型数据的指针”
  - 可以指向任何类型的数据（int、char、结构体等），但不能直接解引用（因为不知道指向的数据类型），void* 指针可以是 “有效指针”（指向实际内存），也可以是 “空指针”（当赋值为 NULL 时）
  - 用途是作为 “通用接口”，例如函数参数 / 返回值需要接收 / 返回任意类型的指针时（如内存分配函数 malloc 返回 void*）

## malloc函数实现的底层原理，如果用C去实现的话，有什么思路吗？

## 最小堆特性是什么？为什么队列的实现要用到堆？

## lvgl是如何与底层硬件联系起来的呢？

## 你的项目为什么要采用这样的技术方案？

- 在重申一下这个项目方案是基于“PC上位机 - 中控器 - 多传感器”三层架构的分布式工业设备管理系统，核心目标是实现对多个工业传感器的集中管控
- 硬件方案：xxx（中控作为网关，减轻上位机的实时采集压力，并扩展了系统的带载能力，如此的思想比如我们的USB Hub）
- 软件方案：xxx
- 这样做的好处：可靠性、稳定性、可拓展性、维护性和可升级、成本和效率

## 为什么FreeRTOS的任务切换不是在SysTick的ISR？而是在PendSV的ISR？

- 核心原因是为了 保证中断响应的实时性、灵活控制任务切换时机、避免中断嵌套冲突；是由两者的硬件特性和 FreeRTOS 的实时性设计目标共同决定的
- 保证中断响应的实时性
  - 任务切换需要执行 上下文保存 / 恢复（保存当前任务的寄存器、栈指针，恢复新任务的状态），这个过程耗时相对较长（微秒级）
  - 若在 SysTick 中断中直接做任务切换：SysTick 中断有固定优先级（可能高于某些外设中断），任务切换过程会 “阻塞” 其他低优先级中断，甚至可能打断正在处理的高优先级外设中断（如传感器数据采集、紧急故障处理），导致实时性敏感的操作延迟，这样就不那么实时性了
  - 放在 PendSV 中：PendSV 被配置为 系统最低优先级，只有当所有高优先级中断（如 UART、SPI、外部中断等）都处理完毕后，才会响应 PendSV 异常并执行任务切换。这确保了 “高优先级中断优先处理”，不会被任务切换打断，符合实时系统的核心需求
- 灵活控制任务切换时机
  - 任务切换的触发时机不是唯一的
- 避免中断嵌套冲突
  - 若系统存在中断嵌套（低优先级中断被高优先级中断打断），直接在 SysTick 中切换任务可能导致上下文混乱
  - 假设 SysTick 中断触发时，系统正在处理一个更高优先级的外部中断（如电机故障中断），此时若强行切换任务，会导致外部中断的上下文被破坏
  - PendSV 因优先级最低，会等所有嵌套的中断都退出后才执行，确保任务切换发生在 “中断安全点”（无任何中断正在执行），避免上下文冲突
- 实际上，SysTick 与 PendSV 是协作关系，而不是对立的，SysTick 中断：负责 “触发调度检查”—— 在中断中更新任务延时、检查时间片，若发现需要切换任务（如高优先级任务就绪、时间片耗尽），则 设置 PendSV 悬起位，然后立即退出中断
- PendSV 异常：检测到悬起位被设置后，在低优先级下执行 实际的任务切换

- FreeRTOS的任务切换是通过修改栈指针和PC程序计数器来 实现 硬件上下文切换，而不是通过操作系统调度器“主动分配CPU”，具体而言
  - 任务切换的本质是从一个任务栈切换到另一个任务栈，恢复新任务的运行情况

## 可能你会疑问，PendSV在切换任务时，会不会被其他高优先级打断，如果恰好此时有任务要切换呢？

- 首先，PendSV 的 ISR 的整体执行过程允许被高优先级中断打断，但是一旦进入任务切换核心步骤，就不会再被打断了，因为这是原子性的
  - 任务切换的原子性，指的是“当前任务上下文的保存” 和 “新任务上下文的恢复” 这两个过程必须连续执行，不能被任何中断（包括高优先级中断）打断，否则会导致 CPU 寄存器状态混乱
- FreeRTOS 在 PendSV 的 ISR 中通过关闭全局中断来保证这一原子性，也会有硬件来支持：Cortex-M核会自动的去将部分寄存器去压栈，这是不需要软件干预的，且不可被打断
