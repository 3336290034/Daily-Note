# 今天是9月17号的八股文，九月已经过半

## 为什么我们的单片机需要bootloader？

- Bootloader是一段`固化在单片机特定区域存储区域的小型程序`，大小通常只有几KB到十几KB
- 核心逻辑很简单：`上电 -> 初始化硬件 -> 判断是否需要加载新程序 -> 引导用户程序执行 -> 或者接收新程序并写入存储区`

- 没有bootloader，让单片机的开发设计停留在demo级，而无法进入到产品级的设计；如果没有bootloader，单片机的烧录、运行、更新都会变得很难，这种情况下只能用`仿真器`去烧写
  - 有了bootloader，它可以接管烧录任务，支持通过串口、USB、SPI等通用接口接收程序，再自动写入Flash
  - 这意味着：量产或现场维护时，不用拆设备接仿真器，一根 串口线/USB线 就能烧程序，极大降低了操作门槛和成本，实际生产中常用的IAP、OTA升级都是基于bootloader实现的，这样极大地提高了生产效率（也支持批量烧录哇）
  - 所以也可以理解成：bootloader是“实验室调试”，到“实际产品”的桥梁

- 引导用户程序执行：不止于`初始化`，更在于`程序的管理和跳转`
  - 启动文件中的Reset Handler确实会做一些初始化（如设置堆栈、`中断向量表重映射`、`全局变量初始化`等），这是`用户程序自身的启动准备`，而我们的Boot程序要的是引导`更高层次的程序调度`
    - 第一个很明显的就是`选程序`执行：上电后，bootloader会检查`启动条件`，来引导程序是进入Bootloader升级模式还是正常APP模式； 这就和Reset Handler区别开了，Reset Handler程序是没有选择权的，他只是程序内部的开机准备，只能在Bootloader跳转后执行
  - 不同的用户APP可能对硬件有不同的要求，但Bootloader会先完成`最基础且通用的初始化`（如时钟配置到最高频、初始化常用通信接口、关闭watchdog等），确保无论后续运行哪个版本的用户程序，都能在一个“标准环境”中启动
    - 而 Reset Handler 中的初始化是用户程序自己的个性化配置（比如某个用户程序需要低功耗时钟，另一个需要外设特定参数），它依赖于Bootloader先建立的基础环境

## Bootloader和启动文件有什么不一样和联系呢？

- 结合上面的内容
- 启动文件（含 Reset Handler）≠ Bootloader，两者是 “被引导者” 与 “引导者” 的关系
- 启动文件（如 ARM 芯片的 startup_stm32f103xe.s）本质是用户程序的 “启动前缀”，它和用户的 main 函数属于同一个 “程序实体”，而 Bootloader 是独立的 “另一个程序”
  - Bootloader，独立的、受保护的 Flash区域（如起始扇区）
  - Reset Handler，与用户程序在同一区域（用户程序的开头），被Bootloader跳转后才运行

- 都用汇编去写，Bootloader 的底层部分（尤其是启动阶段）常用汇编编写，原因和启动文件用汇编一样
  - 需直接操作特殊寄存器（如中断向量表、堆栈指针 SP、程序计数器 PC），汇编更直接
  - 要最小化代码体积（Bootloader 通常限制在几 KB），汇编更容易控制细节

- Bootloader 的汇编代码是 “为自身服务”，最终会根据判断跳转到用户程序的起始地址（即用户程序的启动文件入口）
- 启动文件的汇编代码是 “为用户程序服务”，最终会跳转到用户程序的 main 函数

## 中断向量表重映射，这是啥？全局变量初始化，是初始化了哪些全局变量啊？MSP和PSP两个指针吗？

- 豆书记一步到位：<https://www.doubao.com/thread/w0d35893a30ac4410>

## 为什么程序有时需要定义一个静态变量？

- <[text](https://www.doubao.com/thread/wc7e0ffa6865c7402)>
- 需在函数多次调用间 “保留状态”
- 限制全局变量的作用域，避免命名冲突

- 实现类级别的共享数据（面向对象中）
- 减少全局变量的使用（更安全的封装）

## 回调函数是什么，什么时候会需要用到？

- 豆书记有话说：<https://www.doubao.com/thread/wd383d5442df50ba1>
