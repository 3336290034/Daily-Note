# Just do it, Don't be lazy

## 嵌入式开发的设计模式有哪些？

- 嵌入式开发的设计模式需结合其`资源受限`（内存、算力有限）、`实时性要求`高、强`硬件依赖`、`稳定性`优先等特点，更注重`轻量性`、`效率`和`硬件交互`的可控性

- 硬件抽象层：HAL(Hardware Abstraction Layer)
  - 核心：通过抽象接口隔离硬件操作与上层逻辑，将寄存器操作、引脚控制等硬件细节封装在底层，上层通过统一接口调用

```c
例：同一传感器（如 IIC 温湿度传感器）在不同 MCU（STM32、ESP32）上的驱动，通过 HAL 接口统一为sensor_init，sensor_read，上层无需修改即可适配不同硬件

// sensor_hal.h（抽象接口）
typedef struct
{
    void (*init)(void);       // 初始化传感器
    float (*read_temperature)(void);  // 读温度
    float (*read_humidity)(void);     // 读湿度
} SensorHAL;

// 实例化：STM32平台的传感器接口
extern const SensorHAL sht30_stm32_hal;
// 实例化：ESP32平台的传感器接口
extern const SensorHAL sht30_esp32_hal;
```

- 状态机模式：State Machine
  - 核心：将系统行为分解为`状态`与 `状态转换条件`，用表格或逻辑判断管理状态切换，适合处理设备生命周期（初始化→运行→休眠→故障）等场景

```c
例：智能灯的工作状态管理（待机→开灯→调亮度→关灯）
// 状态定义
typedef enum {
    LIGHT_STANDBY,   // 待机
    LIGHT_ON,        // 开灯
    LIGHT_DIMMING,   // 调亮度
    LIGHT_OFF        // 关灯
} LightState;

// 状态机处理函数
void light_state_machine(LightState* current_state, uint8_t event) {
    switch(*current_state) {
        case LIGHT_STANDBY:
            if (event == EVENT_BUTTON_PRESS) {  // 按键按下
                *current_state = LIGHT_ON;
                turn_on_led();  // 执行开灯动作
            }
            break;
        case LIGHT_ON:
            if (event == EVENT_BUTTON_HOLD) {   // 长按按键
                *current_state = LIGHT_DIMMING;
                start_dimming();  // 开始调亮度
            } else if (event == EVENT_BUTTON_PRESS) {
                *current_state = LIGHT_OFF;
                turn_off_led();
            }
            break;
        // 其他状态逻辑...
    }
}
```

- 生产者-消费者模式：Producer-Consumer
  - 核心：通过缓冲区（如环形队列）分离数据产生（生产者，如传感器采集）和数据处理（消费者，如算法计算），解决两者速度不匹配的问题

```c
例：摄像头采集（生产者）与图像识别（消费者）的同步

// 缓冲区定义（环形队列）
#define BUFFER_SIZE 5
uint8_t image_buffer[BUFFER_SIZE][640*480];  // 存储5帧图像
uint8_t prod_idx = 0, cons_idx = 0;          // 读写索引

// 信号量（FreeRTOS为例）
SemaphoreHandle_t empty_sem;  // 空缓冲区计数（初始=BUFFER_SIZE）
SemaphoreHandle_t full_sem;   // 满缓冲区计数（初始=0）
SemaphoreHandle_t mutex;      // 保护缓冲区索引

// 生产者任务（摄像头采集）
void producer_task(void* arg) {
    while(1) {
        xSemaphoreTake(empty_sem, portMAX_DELAY);  // 等待空缓冲区
        xSemaphoreTake(mutex, portMAX_DELAY);
        
        // 采集一帧图像到缓冲区
        camera_capture(image_buffer[prod_idx]);
        prod_idx = (prod_idx + 1) % BUFFER_SIZE;
        
        xSemaphoreGive(mutex);
        xSemaphoreGive(full_sem);  // 通知消费者有新数据
    }
}

// 消费者任务（图像识别）
void consumer_task(void* arg) {
    while(1) {
        xSemaphoreTake(full_sem, portMAX_DELAY);   // 等待有数据
        xSemaphoreTake(mutex, portMAX_DELAY);
        
        // 处理缓冲区中的图像
        image_recognize(image_buffer[cons_idx]);
        cons_idx = (cons_idx + 1) % BUFFER_SIZE;
        
        xSemaphoreGive(mutex);
        xSemaphoreGive(empty_sem);  // 释放缓冲区
    }
}
```
  
- 分层架构模式：Layered Architecture
  - 核心：这个更多的是`按功能分层`，每层仅与上下层交互，降低耦合度，提高可维护性

```c
像我们用过的USBx组件，它的架构就是典型的分层架构模式

├─ 硬件层：GPIO、IIC外设（直接操作寄存器）
│  └─ i2c_hw.c（STM32的IIC寄存器配置）
├─ 驱动层：传感器驱动（基于硬件层封装）
│  └─ sht30_driver.c（实现sht30_init()、sht30_read()）
├─ 中间件层：数据处理与通信协议
│  ├─ data_process.c（温湿度数据校准、格式化）
│  └─ mqtt_client.c（封装MQTT连接、发布接口）
└─ 应用层：业务逻辑（调用中间件）
   └─ app.c（定时采集→处理→上报云端）
```

- 命令模式：Command

```c
例：机器人遥控器（封装 “前进、左转、发射” 等指令）

// 命令接口定义
typedef struct {
    void (*execute)(void);  // 执行命令
    const char* name;       // 命令名称
} Command;

// 具体命令实现
void cmd_forward_execute() {
    motor_set_speed(LEFT, 50);
    motor_set_speed(RIGHT, 50);
}
Command cmd_forward = {.execute = cmd_forward_execute, .name = "forward"};

void cmd_turn_left_execute() {
    motor_set_speed(LEFT, -30);
    motor_set_speed(RIGHT, 30);
}
Command cmd_turn_left = {.execute = cmd_turn_left_execute, .name = "turn_left"};

// 命令管理器（存储和执行命令）
typedef struct {
    Command* cmds[10];
    uint8_t count;
} CommandManager;

void cmd_manager_add(CommandManager* mgr, Command* cmd) {
    mgr->cmds[mgr->count++] = cmd;
}

// 解析遥控器指令并执行
void remote_control_task() {
    CommandManager mgr = {0};
    cmd_manager_add(&mgr, &cmd_forward);
    cmd_manager_add(&mgr, &cmd_turn_left);
    
    while(1) {
        char* cmd_str = remote_receive();  // 接收遥控器字符串（如"forward"）
        // 查找并执行命令
        for (int i=0; i<mgr.count; i++) {
            if (strcmp(cmd_str, mgr.cmds[i]->name) == 0) {
                mgr.cmds[i]->execute();  // 执行对应动作
                break;
            }
        }
    }
}
```

- 事件驱动模式：Event-Driven
- 单例模式：Singleton
- 豆书记有话说：<https://www.doubao.com/thread/w95b4dc4197955ce6>
