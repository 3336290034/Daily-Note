# 弥补算法编程基础---就从这里启航吧，加油

## 如何遍历一个整数

- 直接上代码：不转换成字符串

```c
int num = 123;
int g_wei = num % 10; // 个位
int s_wei = (num / 10) % 10; // 十位
int b_wei = (num / 100) % 10; // 百位

while循环重写：
int wei_sum = 0;
while (num)
{
    wei_sum = wei_sum * 10 + num % 10;
    num /= 10; 
}
if (num == wei_sum)
{
    // 是回文数
    // 用这个思路也可以反转整数
}
```

- 转换成字符串：

```c

```

## 罗马数字转整数

```c
int romanToInt(char * s){
    int strLength = strlen(s), flag = 0,sum =  0,flag_1 = 0;
    --strLength;
    for(;strLength >= 0;--strLength){
        switch(*(s+strLength)){
            case 'I': flag = 1;break;
            case 'V': flag = 5;break;
            case 'X': flag = 10;break;
            case 'L': flag = 50;break;
            case 'C': flag = 100;break;
            case 'D': flag = 500;break;
            case 'M': flag = 1000;break;
        }
        flag_1 = flag_1 > flag ? -flag : flag;
        sum += flag_1;
    }
    return sum;
}

也可以采用映射的思想：

int romanToInt(char* s) {
    int roman[128]; // 保证可以容纳所有 ASCII 字符
    // 单个罗马数字到整数的映射
    roman['I'] = 1;
    roman['V'] = 5;
    roman['X'] = 10;
    roman['L'] = 50;
    roman['C'] = 100;
    roman['D'] = 500;
    roman['M'] = 1000;

    int ans = 0, i = 1;
    for (; s[i]; i++) { // 遍历 s
        int x = roman[s[i - 1]], y = roman[s[i]];
        // 累加 x 的数值，y 只是用来辅助判断 x 的正负
        ans += x < y ? -x : x;
    }
    return ans + roman[s[i - 1]]; // 加上最后一个罗马数字
}
```

## 对于字符串数组的遍历

- 直接上代码：

```c
 // 1. 定义3个字符串（本质是char*指针）
char *s0 = "zhu";
char *s1 = "ya";
char *s2 = "feng";
// 2. 定义一个指针数组，存放这3个字符串的地址
char *str_arr[] = {s0,s1,s2};
 // 3. 用char**指针指向这个数组的首地址
char **strs = str_arr;
// 4. 访问字符串（和指针数组的用法完全一致）
printf("%s\n", strs[0]);  // 输出 "zhu"
printf("%c\n", strs[2][1]);  // 输出 "feng"的第2个字符 'e'

补充：数组作为函数参数时，会自动退化为指向数组首元素的指针
```

## 邻项消除

```c
bool isValid(char* s) 
{
    char mp[128] = {0};  // 给所以左括号赋值为 0，后续判断 “是否为左括号” 的关键
    // 只有右括号有初值
    mp[')'] = '(';
    mp[']'] = '[';
    mp['}'] = '{';

    int top = 0;
    for (int i = 0; s[i]; i ++)
    {
        char c = s[i];
        if (mp[c] == 0)     // 说明是左括号
            s[top++] = c;
        else if(top == 0 || s[--top] != mp[c])  // 如果一上来就是右括号 或者 s中相邻的没有对应的左括号与之匹配
            return false;
    }
    return top == 0;    // 所有左括号必须匹配完毕
}
```

## 经典排序算法

## 删除数组重复项

## 寻找字符串最大数

```c
int main(void)
{
    char str[128];
    scanf("%s", str);
    int len = strlen(str);
    int num = 0, cnt = 0, max = 0;

    for (int i = 0; i < len; i ++)
    {
        if (str[i] >= '0' && str[i] <= '9')
        {
            num = num * 10 + (str[i] - '0');
            cnt ++;
            if (num > max)
                max = num;
        }
        else
        {
            num = 0;
            cnt = 0;
        }
    }
    printf("%d\r\n", max);
    return 0;
}
```

## 对于需要变长数组的方法

```c
int cnt;
scanf("%d", &cnt);

- 使用malloc
int *arr = malloc(cnt * sizeof(int));
// 填充数组
for (int i = 0; i < max; i++) {
    arr[i] = i + 1;  // 存储1到max的整数

- 如果是C99的话
int arr[cnt] = {};
```
