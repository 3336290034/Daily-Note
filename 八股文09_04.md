# 汇顶一面准备  && 星宸一面准备

## 中控是如何访问任意传感器的？（上位机访问···过渡）（程序是如何设计的）

- 在前面传感器程序设计的基础上：需要实现：点表映射---传感器中的buffer映射到中控的buffer
- 创建中控任务：去访问实际的传感器数据
  - 任务 1：创建一个 Modbus 设备，分配 modbus_mapping_t，读取 PC 发来的请求并进行回应
  - 任务 2：使用 CH1 访问开关量传感器（ID=1），在 modbus_mapping_t 和传感器之间传递数据
  - 任务 3：使用 CH1 访问环境监测传感器（ID=2），在 modbus_mapping_t 和传感器之间传递数据
  - 任务 4：使用 CH2 访问温湿度传感器（ID=3），在 modbus_mapping_t 和传感器之间传递数据
  - 根据任务一，去选择要读写的传感器（DO寄存器）
    - 怎么实现的呢？（先执行操作，后更新寄存器）
    - 最开始就备份当前DO寄存器的值到一个局部变量，然后在循环中不断的和modbus_mapping_t比较、判断
    - 有需要的话就是释放对应任务的信号量，让任务去操作对应的 传感器的modbus_mapping_t（寄存器）
  - 在其余三个任务中，会不断的去读取去更新全局变量g_modbus_mapping_t，也会根据g_modbus_mapping_t的值，去更新对应的 传感器的modbus_mapping_t（寄存器）
<!-- 对于DO寄存器的操作，我会创建一个中控Server -->

## PC上位机是如何实现访问任意传感器的？

- 我会建立一个PointMap结构体，来描述中控（主控）和传感器之间的“点”映射关系，把主控系统的寄存器和外部传感器的寄存器一一对应起来，方便统一读写和管理

## 聊一聊FreeRTOS的内存管理是怎样的？

- heap_1：仅分配不释放（最简单）
- heap_2：支持分配与释放，但不合并碎片
- heap_3：封装标准 C 库的 malloc/free
- heap_4：支持碎片合并（最常用）
- heap_5：支持非连续内存区域

## 你在这个实习是做了什么事情？

## 你说下你移植这个实现usb的过程

## 介绍一下你的这个项目

## 等于说你这个项目，你就是负责上位机的开发和接口的封装裸机是吧

## 你了解Linux吗？

## 你上位机开发用的lvgl，我想问一下你为什么不去使用Qt？

## 你讲一下啊编译的过程

## 你的职业规划是什么？

## 你有在你大学期间主动学习过什么吗？

## 那这些对你的职业规划有什么帮助吗？

## 这个Modbus通信是什么？

## USB的这个描述符也是你自己去实现的吗？
