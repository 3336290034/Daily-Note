# 八股文，接着理解接着背

## 如何将字符串转换为数字？

- 当我们用键盘输入时，没按下一个按键，与键盘按钮对应字符 关联的ASCII码就会被 存储在一个buffer中，所以你哪怕输入的是数字，实际上程序或者PC看到的也只是纯文本

```c
for (int i = 0; s[i] != '\0'; i++)
{
    if (s[i] < '0' || s[i] > '9')
        return -1;
    res = res * 10 + (s[i] - '0');
}
```

## 程序和进程

- 程序是被动的实体，静悄悄地躺在磁盘上，等待你点击它告诉计算机，开始运行它
  - 要运行程序，首先需要加载到内存中，因为那是CPU获取指令和数据的地方
  - 当加载到内存中时，包含可执行代码地部分被称为文本段（代码段），而像全局变量常量这些的则被加载到数据段，除此之外还需要额外地内存空间来存储程序运行时产生地所有数据，如用户输入数据/临时结果或者变量

  - 所以程序最初被加载到内存中时，就只有两个段（数据段包含了bss段），先记住这个布局
  - 但是当程序运行起来时，正如前面所说，这种布局不再可以被认为是程序了，它现在被称为进程了

  - 文本段（代码段）是唯一一个既不会变大小，也不会变内容的段
- 进程是主动的实体，它是程序的一次执行过程

## volatile关键字的作用

- 豆书记有话说：<https://www.doubao.com/thread/wcb68ce68bf4c860f>
- 核心总结就是：阻止编译器对变量的访问进行`缓存优化`，强制程序每次访问改变量时都要从其内存地址直接读取，同时也会组织编译器对该变量的写操作进行延迟或者重排序
- 使用场景：主要用于变量的值可能被`当前代码之外的因素` 修改的场景
  - 硬件寄存器访问
  - 中断服务程序（ISR）与主程序共享的变量
  - 多线程共享的变量（有限场景）
- 局限性在哪？对它的错误理解

## 静态库和动态库的区别

- .a/.lib  和  .so/.dll
- 核心区别体现在`链接时机 + 文件依赖 + 内存占用`这几个方面

- 链接时机 和 文件依赖
  - 静态库实际上是一系列目标文件(.o/.obj)的集合，在程序的编译阶段就已经被完整的`复制`到最后生成的可执行文件中；一旦链接完成，静态库就不会单独存在，可执行文件和静态库将彻底地绑定在一起
  - 动态库实际上是独立地`二进制文件`，在程序编译时仅仅是记录文件地`引用关系`；不会被复制到可执行文件中；直到程序运行时，才由操作系统加载到内存并动态链接
  - 多个程序可共享同一份动态库的内存副本
- 内存占用
  - 静态库：较大（包含库的完整代码），多个程序使用时，每个程序都有一份库副本（冗余）
  - 动态库：较小（仅包含库的引用），多个程序共享同一份库内存（节省资源）
- 更新维护
  - 静态库：库更新后，所有依赖它的程序必须重新编译链接
  - 动态库：无需重新编译程序，仅需更新动态库文件即可
- 加载速度
  - 静态库：启动快（无需运行时加载库）
  - 动态库：启动稍慢（需加载库并动态链接）
- 使用场景
  - 优先用静态库：程序需要 “独立部署”（如嵌入式设备、无依赖的工具），或对启动速度要求极高（如实时系统）
  - 优先用动态库：多个程序共享同一库（如系统级库 libc.so），或需要频繁更新库（如插件化程序、系统组件）

## 程序的栈溢出是如何被攻击的？常说的段错误是什么？

- 豆书记有话说：<https://www.doubao.com/thread/wd9f3291d73de0e04>
- 记住：我们栈现在一般都说`满递减栈`，地址由高向低处增长，存在栈帧中的数据是由低向高处存储的，当局部变量的输入数据超过其缓冲区大小时，就会`溢出`到栈的高地址区域，覆盖后续存储的返回地址、栈基指针等关键数据

- 这里就再补充一个常见的概念：关于内存泄漏
- 豆书记有话说：<https://www.doubao.com/thread/wc5f5f9401e772f74>

## 通信协议错误的排查，你会怎么做，HR问的话

- 物理层排查：最优先，占比 70% 以上的通信问题根源
  - 接线正确性：确认`关键信号线` 是否接对（如SDA/SCL、MOSI/MISO、TX/RX），是否存在`交叉接反`或`错接引脚`
  - 供电与共地：用万用表测量从设备供电电压（如3.3V/5V）是否符合手册要求（电压不足会导致设备不响应）；必须确保主从设备共地（参考地连通），否则信号无`基准电平`，必然通信失败
  - 线路完整性：检查线缆是否`断线/短路`（用万用表通断档测信号线），线路是否过长（如IIC超过1米、UART超过10米需考虑衰减）或附近有强干扰（如电机、开关电源）
  - 协议特有的硬件配置：如IIC的上拉电阻、SPI的片选引脚、CAN的终端电阻等，需按协议规范配置

- 协议层排查：用工具抓`波形/数据`，验证`时序与帧格式`
  - 时序参数：确认`时钟频率`（如IIC 100kHz/400kHz、SPI 1MHz/10MHz）、`数据建立/保持时间`是否符合设备手册（高速模式下时序不匹配会导致数据解析错误）
  - 帧格式：检查协议的 “起始位/停止位、地址位、数据位、校验位” 是否正确（如UART的 8N1 格式、SPI的 CPOL/CPHA模式、IIC的ACK信号）
  - 交互逻辑：确认主从设备的交互流程是否符合规范（如 “先发地址再发数据” “读前需写寄存器地址”）

- 软件层排查：代码逻辑与配置验证
  - 外设初始化：确认主设备的协议外设配置正确（时钟源、GPIO模式、协议参数这些）
  - 读写流程：严格按从设备手册的`读写时序`编写代码（如SPI读数据前需拉低CS、IIC读操作需设置地址最高位为 1）
  - 错误处理：是否捕获协议外设的错误标志（如 IIC无ACK、UART帧错误、SPI溢出错误），是否有`重试机制`（应对偶发干扰）
  - 延时与等待：部分设备（如传感器）需要时间处理数据（如 AD转换），需在读写间加合理延时，避免`读空数据`

- 简化与替换验证（快速缩小问题范围）
  - 最小系统测试：只保留`主设备+单个从设备+必要供电/信号线`，移除其他模块（如显示屏、按键），排除多设备干扰
  - 硬件替换验证

## 线程间有哪些同步机制？线程间的竞争问题怎么解决？

- 我的第一反应是联想到RTOS关于多任务的处理，我这个思路是不是对的？
- 豆书记表示很认可：<https://www.doubao.com/thread/w3f23a41ad566363d>
