# 汇顶一面准备

## usbx移植后，是怎么下FreeRTOS下进行改造的

- 先回答你改造的点在哪里，是如何进行改造的

## 项目为什么要用Modbus，Modbus有什么优势？对EtherCat有了解吗？

- 首先，根据我们项目软件方案：PC上位机-中控-传感器，选择Modbus协议，完全贴合方案设计的核心需求；然后，看看Modbus的优势：
  1. Modbus 是完全开源且无任何专利或授权费用的协议
  2. Modbus 是工业领域 “兼容性天花板” 级别的协议，项目中使用Modbus协议也是为日后工作打下基础
  3. Modbus 易用性拉满：协议简单，开发 / 调试成本低
  4. Modbus 支持多种传输介质：串口、TCP/IP等，灵活适应不同场景需求，物理层的 “兼容性” 让它能适配几乎所有场景，所以我们的项目叫通用型解决方案
- 对EtherCat的了解：
  1. EtherCat 是一种实时以太网技术，主要用于工业自动化领域，具有高性能、低延迟的特点。
  2. EtherCat 通过主从架构实现设备间的高速通信，适合大规模的分布式系统。
  3. 相比Modbus，EtherCat在数据传输速率和实时性方面更具优势，但其复杂性和成本也相对较高。

## Modbus通信的数据帧

- 起始间隙(3.5个字符)  设备地址  功能码  起始地址  寄存器数  数据量  数据  CRC校验  停止间隙
- 常见的功能码有...(单/多线圈，单多寄存器)
- Modbus的通信过程是怎样的？
  1. 主机发送请求帧，包括设备地址、功能码和数据
  2. 从机接收到请求后，进行处理并返回响应帧
  3. 主机接收到响应帧后，进行数据解析和处理
  4. 如果出现任何差错，从设备将返回一个异常功能码
- 如按照项目中，则隐含了对串口速率的要求<https://www.doubao.com/thread/w3986aadd605b3080>

## 说说你对Modbus协议的理解  ❓

## 说说你libmodbus移植的过程

- 首先，libmodbus是一个免费的跨平台支持RTU和TCP的Modbus库，并支持通过串口或者TCP网络进行连接，用的是3.10.1的版本
- 在移植的时候，我更多的是参照源码去分析和理解：
- 参看源码给的client和server示例程序，分析主从设备的数据收发流程框架、其中用到的核心函数、数据结构这些❓
  - 核心数据结构：
    1. 核心层 modbus_t 结构体               （关于通信的一些设置）
    2. 传输层 modbus_backend_t 结构体         （对接硬件的具体函数，后端实现）
- 在前一步的工作上去学习和理解，最终改造实现自己的modbus通信，适配项目需求，下面我展开说说libmodbus的层次架构：libmodbus分为三层
  1. 应用层：它知道要做什么，主设备要读写哪些寄存，从设备提供、接收什么数据
  2. 协议层：向上提供接口函数，向下调用底层代码构造数据包并发送、接收数据包并解析
  3. 传输层：负责底层的串口或网络通信，提供数据的发送和接收功能，进行硬件相关的数据封包与发送、接收与解包
- 移植的核心工作：就是实现自己的‘传输层’的核心结构体 modbus_backend_t 结构体
- 我们只需使用对于物理总线用到的函数，填入该结构体即可，最后加上APP的逻辑实现，实现我们自己的modbus通信

## 你的传感器是怎么设计的？

- 其实就是问你程序是怎么写的：
- 要清楚传感器在项目中的作用和定位，在这个项目中，负责和传感器对接的是中控，中控通过modbus访问传感器时，本质上是读写传感器stm32f030分配的四类‘寄存器’，或者说buffer
- 所以现在我们面临的问题就是：
  1. 这些数据缓冲区buffer该如何设计？大小是多少？起始地址是多少？
  2. 这些buffer的值，如何和硬件对应？谁来提供这些值？
- 上述的第一点，就是我们项目中提及的点表，点表中的点对应着一类寄存器的某一个（包括地址、功能这些信息），点表的设计要根据实际情况而定，是由开发人员完全设计的
- 最后我们根据用到的传感器，分析它们的功能，确定四类传感器的中每类寄存器的个数、起始地址，确定我们最后的点表设计
- 在实际的程序设计中，我会创建一个modbus_mapping_t结构体，来描述传感器硬件和modbus寄存器之间的映射关系
  - 将读取到的传感器数据，存放到modbus_mapping_t的对应寄存器中，由此就完成了硬件和modbus寄存器的映射
  - 这个过程会在For循环里面不断进行，确保数据的实时更新

## 你FreeRTOS的任务是如何设计的？

- 在设计RTOS的任务时，主要还是考虑一下几个方面：可靠性、实时性、资源安全性
- 可靠性：引入队列：生产者-消费者 模型，同步机制会使任务自动阻塞，不会让CPU干等着
  1. 生产者：UART 中断回调（xQueueSendFromISR）、传感器读取任务（xQueueSend）
  2. 消费者：UART 数据解析任务（xQueueReceive）、Modbus 主机任务（xQueueReceive）
- 实时性：引入队列，避免单任务阻塞导致所有功能延迟，及时释放信号量/互斥锁（前take后give），时间片轮转调度策略：避免执行初始化等操作
- 资源安全性：多任务访问同一个外设资源，引入互斥锁

## 在任务中使用RTOS队列的好处是什么？

- 解耦任务：发送方和接收方不需要直接调用对方，只需操作队列即可
- 自动同步：队列满或者空 时，任务会自动挂起或唤醒，无需开发人员手动管理
- 灵活性高：可以用于一对一，一对多，多对一等多种任务通信场景
