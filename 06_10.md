/* 遇到的问题 */
1， Linux 默认给每个[用户进程栈]分配 8MB 大小的空间
2， 在 Linux（以及主流操作系统）中，char 类型的大小固定为 1 字节（8 位），这是 C/C++ 语言标准的强制要求
3， Segmantation fault (core dumped)  :  段错误（核心已转移） [为什么报错是段错误？想一想] ：猜测这里的段指的是 数据段

4， gcc 指令生成汇编文件 ：gcc -S [可选项] 源文件.c -o 输出文件名.s
    下面两个有区别：
        zyf@zyf-virtual-machine:~/桌面/test4$ arm-linux-gnueabi-gcc -S main.c -o f.s
        zyf@zyf-virtual-machine:~/桌面/test4$ arm-linux-gnueabi-objdump -D b.out > d.s

5， Linux・系统调用：是应用程序 与 内核 进行交互（向内核请求一些操作如访问硬件、内存管理等）的唯一安全接口；它将复杂的硬件操作和内核功能封装为标准化接口，使应用程序无需关心底层细节

6， man 指令 [查看命令用法、手册] 在 Linux 系统中，man 命令（Manual 的缩写）是一个核心工具，用于查看系统手册页（manual pages），获取命令、函数、配置文件等的详细文档。
    掌握 man 是 Linux 用户和开发者必备的技能之一                        ** Man !!!

7， 内存填充函数 memset() 和 内存复制函数 mencpy() 的语法，要熟悉 // 前一个多用于“内存（数组/结构体）的初始化（一般初始化为unsigned char类型的0”）
8， Linux删除文件夹命令，分为 [空文件夹和非空文件夹] 两种情况
    [text](https://www.doubao.com/thread/wa607708c25b3ee05)

9，在Linux中，用户通过 free() 释放的内存并不会马上立即归还给操作系统、而是被用户空间的 ptmalloc 接收并添加到一个空闲链表中；
    内存管理的 **bin机制  
        有fast_bins \ small_bins \ large_bins \ unsorted_bins;
        在合适的时机，会合并连续的空闲内存;

10， 零数组的用途：

11， 不是，你在学什么啊？？？ [代码段、数据段这些是在堆空间还是在栈空间？]  [text](https://www.doubao.com/thread/w5d4900e61ab8dcf6)
    1. 静态段的本质：编译时确定布局，加载时一次性分配，运行时结构固定

                                                        +------------------+
                                                        |  代码段（Text）   |  ← 低地址
                                                        +------------------+
                                                        |  常量段（RO Data）|
                                                        +------------------+
                                                        |  数据段（Data）   |
                                                        +------------------+
                                                        |    BSS段         |
                                                        +------------------+
                                                        |     堆（Heap）    |  ← [heap:向上增长]
                                                        +------------------+
                                                        |     内存映射区    | （如共享库、mmap文件）
                                                        +------------------+
                                                        |     栈（Stack）   |  ← [stack:向下增长]
                                                        +------------------+
                                                        |     内核空间      |  ← 高地址，向下增长
                                                        +------------------+

为什么每次打印的代码段、数据段这些段（静态）的地址都不一样？[text](https://www.doubao.com/thread/wd3e29ae2917c5a37)

        1. ** bushi... ，malloc() 分配的内存属于动态内存，而非静态内存
12， 静态段与动态段的本质区别
    1. 静态段的 “静态性” 体现在：
        编译时确定布局：代码段、数据段的大小和内部变量的偏移量在编译时已确定。
        [加载]时一次性分配：程序启动时，操作系统按 ELF 文件的段信息直接映射内存。
            :从 ELF 到内存的映射过程
        运行时不可扩展：数据段的大小在运行中不会变化（如全局数组 int arr[100] 始终占 400 字节）。
    2. 动态段的 “动态性” 体现在：
        运行时按需分配：堆通过 malloc() 动态申请，栈随函数调用自动扩展。
        大小可变：堆可通过 realloc() 调整，栈深度随递归或大局部变量变化。
        地址不连续：多次 malloc() 的内存可能不相邻（受堆碎片影响）。