# 准备星宸AE二面&&大华一面

## 栈帧里面都保存有哪些信息？

## Linux系统常见的指令和作用？

- cp - 复制文件或目录
- mv - 移动或重命名文件/目录
- cat - 查看文件内容
- head/tail - 查看文件头尾内容
- more/less - 分页查看文件内容
- 无语，浪费啊根据，，，

## 你在代码调试和开发过程中是怎样进行的？

## FreeRTOS的调度过程

- 总的来看，有三种：抢占式、时间片、协作式
- 先说一下啊协作式啊，这个目前使用的频率是很低的，作为工程师的话，我们了解一下，为日后提供思路和方向我觉得就ok了，它的调度逻辑是：
- 剩下两个就是 抢占式和时间片，其实这俩不是`完全的并列关系`，而更像是`包含和被包含关系`的：时间片调度是抢占式调度中处理`同优先级任务`的一种具体方式，而抢占式调度是`更宏观的调度策略`（涵盖不同优先级和同优先级任务的调度逻辑），而且有意思的是，开启时间片调度，必须同时开启抢占式调度的宏开关
- 来看看他们的调度逻辑：
  - 抢占式：xxx
  - 时间片：xxx（只有当存在同优先级的就绪任务时：时间片调度才会生效）
- 实际开发中，两者通常配合使用：通过抢占式调度保证高优先级任务的实时性

- 然后是任务的切换的核心逻辑：本质是暂停当前运行任务的执行状态，恢复另一个就绪任务的执行状态，这里三核心步骤：
- 保存任务上下文
  - 首先就是将当前运行的任务的上下文保存起来，确保后面恢复这个任务还可以继续运行
  - 这一步的触发时机是在 ISR 中实现的（比如SysTick中断），因为中断时“安全切换任务”唯一时机❓
  - 这一步在软硬件层面上体现就是有专用的CPU指令去支持和软件会更新当前任务控制块TCB的SP
- 选择下一个要运行的任务
  - 调度器Scheduler，会根据当前的调度策略从就绪列表找到下一个要运行的（根据优先级/就绪顺序）
  - 这里需要“双向链表这样的数据结构”去做支撑，支持这样的一个操作
- 恢复下一个任务的上下文
  - 硬件层面：同样在PendSV异常中完成
  - 软件层面：将下一个任务 TCB 中的栈指针（SP）加载到 CPU 的 SP 寄存器，确保栈指向正确位置，更新内核的 “当前任务指针”（pxCurrentTCB），标记新任务为 “运行态”

- 最后就是任务切换的触发时机了
- 抢占式触发：高优先级任务从 “阻塞态” 转为 “就绪态” 时（如vTaskDelay延时结束、信号量xSemaphoreGive释放）；中断服务程序（ISR）执行完毕后，检测到更高优先级任务就绪（FreeRTOS 在 ISR 退出前会调用调度器钩子函数）
- 时间片触发：这个就不说多了
- 任务主动放弃 CPU

## 说一个自己最擅长的通信协议

- 如果问你IIC
  - 从设备地址寻址的过程？
  - 多主设备是怎么实现的？
  - 总线仲裁是怎么去做的？

## 内存碎片怎么处理（系统是怎么处理内存碎片的？在实际的开发中，我们要怎么去避免内存碎片带来的问题？）

- 在实际开发中要避免过多的内存碎片：动态内存（malloc/free、new/delete）是碎片的主要来源，尽量用静态内存替代，就比如
  - 定义全局变量或者静态局部变量（编译时分配而不是运行时，生命周期与程序一致）
  - 在嵌入式系统开发中，像传感器数据、协议解析缓冲这些buffer可以预先定义为全局数组，尽量避免运行时去malloc
  - 尽量少在高频次数任务调用这个，，，
- 统一内存分配大小，避免 “碎片化申请”（如果动态分配的频次很高的话，怎么实现呢？❓）
- 使用“内存池”：内存池是预先分配的连续内存块，划分为 N 个大小相同的子块，分配时从池内取一个子块，释放时放回池内（不真正释放内存）
  - 怎么去实现这样一个内存池呢？❓
- 最后就是从内存管理算法入手了

## 什么情况下会用到函数指针，它和指针函数有什么区别吗？

- 作为函数的参数
  - 回调函数的机制：将函数作为参数可传递，像中断处理、时间响应中、用函数指针指定“发生事件时该执行哪个函数
  - 排序经常用的 qsort函数，我们要去实现核心的比较函数，最后再将比较函数名传给qsort函数
- 作为结构体成员
  - 实现多态的（C语言模拟OOP），也就是我们的函数表，通过函数指针可以去模拟C++的虚函数表
  - 外部调用接口抽象+插件系统
- 作为函数的返回值：状态机实现，比如和switch-case语句结合

- 区别：xxxxxx

## [weak]stm32外部中断的实现原理

## 中断上下文是什么？为什么会有上文和下文

## 物理地址和虚拟地址是什么？它们都有什么作用呢？

- 现代计算机系统中，内存管理采用的是“物理地址+虚拟地址”的结合，实现高效、安全的内存访问机制
- 物理地址
  - 就是实际硬件内存的真实地址，是CPU总线通过地址总线发送到内存控制器的地址信号，用于直接定位和访问物理内存在具体的存储单元
  - 它就是与实际的硬件电路相关，不具备抽象性和隔离性，它能表示的地址空间大小与实际的物理内存大小有关
  - 后续的虚拟地址需要建立在此之上
- 虚拟地址
  - 是程序运行时的逻辑地址，是操作系统为每个进程提供的独立地址空间，需要MMU转换为物理地址后才可以访问实际内存
  - 是对物理内存的一种抽象
  - 每个进程有独立的虚拟地址空间，且虚拟地址空间的大小一般大于实际的物理内存容量
  - 因为有MMU和操作sys俩管理，所以他涉及到一个`页表的映射`，因此它是具有隔离性的，进程之间无法互相访问，`确保了进程安全`
- 有了虚拟内存，内存管理更灵活（物理地址不连续，但是我可以让虚拟地址连续），便于实现内存分配和回收（操作系统只需管理虚拟地址空间的分配）；简化程序开发，程序无需关心实际物理内存的布局和分配细节，程序可以使用固定的虚拟地址进行开发，提高了可移植性

- 不错的是，这样的思想（虚拟地址/物理地址的转换），在我的项目里面也有体现
- 使用malloc函数返回的地址也是虚拟地址
- 使用readelf指令查看节头表，看到的地址是虚拟地址

## 在进行内存映射时，分配的是用户空间还是内核空间

## [weak]交叉编译工具链有哪些？

- 最耳熟能详的应该就是GNU Toolchain了

## [weak]CPU如何知道DMA有数据呢？有什么怎么从DMA哪里拿到数据的呢？

## 从函数接口的角度出发，带有const标识的变量是输入还是输出

- 输入，核心意义是：向调用者和维护者清晰传达参数的使用意图——该参数仅用于输入，函数不会修改它，这是良好接口设计的重要原则
- 而且，一般来说，输出参数就不应该使用const修饰，因为输出参数的目的就是为了让函数通过它向调用者返回数据（需要被修改的）
- const的核心作用是像编译器和调用者声明：改变量在函数执行过程中不会被修改，举例：两种常见场景
- const修饰基本类型参数
- const修饰指针指向的数据（最常见的输入参数形式）
- const修饰指针本身（较少用作输入/输出区分，更多是约束指针自身）memcpy/memset/sprintf等等函数
- 豆书记有话说：<https://www.doubao.com/thread/w284758f1fb575a1b>

## 你为什么投递我们公司，你对我们公司有哪些了解？（该从哪些方面去回答）

## 链表有哪些类型？优势都分别是什么？
